# JS 状態管理ライブラリ探索記 - Introduction

## はじめに

これから何回かに分けて、いくつかの JS の状態管理ライブラリを紹介します。
ですが、今回はその前になぜいくつもライブラリを知っていた方がいいのか、当たり前のように思うことをあえて考えてみましょう。

## 状態管理が目指すもの - 読みやすさの基本定理

そもそも状態管理とは、一体何のために、何をすることなのでしょうか？

状態管理をする目的は様々ですが、最も大切なことはリーダブルコードの中で「読みやすさの基本定理」として掲げられた以下に集約されると筆者は思います。

> コードは他の人が最短時間で理解できるように書かなければいけない。

つまり、状態に関係する変数周りやフローのソースコードを、最短で理解できるものとすること。これが状態管理の目的だと筆者は思います。
ここでいう「最短で理解できる」とは、最短でコードに変更を加えたりバグを見つけたりできるという意味が込められています。

この目的を見失わないことが、状態管理において大切なことだと筆者は思います。そうしないと、独りよがりな管理になることもあるからです。そのような管理はどんなに巧妙なことをしていても、理解できないならば開発の勝利条件を満たせないと筆者は思います。
アプリケーションが絶えず成長できることは、勝利条件に含まれるべきでしょう。

## そもそも状態管理するって何をすること？

では、状態管理をする = 最短で理解できる状態周りのコードを目指す ためには何から始めればいいのでしょうか？ よく知られている Redux や他の Flux 的なライブラリを導入することでしょうか？ GitHub のスター数が多くて開発も活発で日本語のドキュメントも充実したライブラリを導入することでしょうか？

筆者が思うに上記は全て間違いです。まずはライブラリのことは全て忘れて、自分が開発するものをよくを知ることです。
インタラクティブのない WEB サイトなのか、WEB アプリケーションなのか。また、そのアプリケーションは複雑なのか、また、複雑になっていくのかといったことをまず自問することです。

インタラクティブのない WEB サイトであれば、JS が複雑ではないかもしれません。そうであれば、特別に状態管理を考慮することは不要です。もしかしたら React や Vue すら不要で、下手するとただの足かせです。

### ソースコードは読みづらくなっていく

ライブラリを一つ導入したり、コードに変数を一つ足すことは、開発者が認識するべきことや場合によっては従うべき規則を増やします。たったこれだけのことでも、ソースコードの読みにくさは少しずつ（でも確実に）増していくものです。つまり、ライブラリを導入すること自体が、コードを読みにくくすることです。

適切に選択されたライブラリは（また足された変数は）、自身が導入されることで発生する読みにくさを上まる利益をもたらしてくれます。それ以外は無用に支払うコストです。基本的には避けるべきものでしょう。

Redux の公式ページにおいても、以下のように述べられています。

> Redux は共有状態管理を扱うのに役立ちますが、他のツールと同様にトレードオフがあります。Redux はコードを書くための最短・最速の方法として設計されているわけではありません。
>
> https://redux.js.org/faq/general#when-should-i-use-redux

最短、最速で「書く」ことを目指す開発の場合はむしろ Redux は足かせであると公式が認めています。

ここで状態管理は何をすることなのかという疑問に対して、こう答えることができるでしょう。

> 複雑でない開発においては、積極的に状態管理をしない

しかし、大規模な SPA を多数の開発者と共同で開発するとなれば、よく考慮して状態管理しなければ「読みやすさの基本定理」を目指すことは困難になります。

### 大規模な SPA で状態管理して読みやすさの基本定理を目指す

大規模な SPA を開発していると、ソースコードは複雑なものに変化していきます。その複雑さに追従、もしくは先周りして安全性を獲得しておくことが、コードを最短で理解しやすくすることにつながります。

全ての状態の所在や流れを認識できればそれは一番安心できますが、それは不可能です。であれば、末端の処理からでもデータの取得や更新の経路を辿れることが大切でしょう。

そのために様々な状態管理ライブラリは、あるデータを参照、更新する際の規則を守ることを開発者に要求します。厳しい規則に従うことは、状態の変化と取得の因果関係をより明確に定義することにつながります。そして、この因果関係の糸がはっきりするものであれば、「読みやすさの基本定理」につながると筆者は思います。

つまり、ここでは状態管理は何をすることなのかという疑問に対してこういうこともできると思います。

> 状態の変化と取得の因果関係をより明確に定義すること

ですが、そもそも何故たくさんのライブラリがあるのでしょうか。

### 状態管理のライブラリが生まれる背景

筆者の経験で想像できることは、アプリケーションの複雑さは 10 のアプリがあれば 10 通り異なるため、様々な複雑さの度合い応じたライブラリが生み出されてきたのではないかということです。

ある状態管理のライブラリを導入することは、ある規則を導入することにつながります。その規則に従うことが利益なのか、無用に支払うコストなのか、それを見定めることが「読みやすさの基本定理」につながります。

だからこそ、開発するアプリに適用する「規則」の選択肢を持つことが重要だと思います。
そこで、その選択肢を増やすために、これから何回かに分けて JS の状態管理ライブラリを紹介していきます。

### どの状態管理ライブを紹介するか - 各ライブラリが持つトレードオフ

比較的新しい状態管理ライブラリ XState の作者 David Khourshid([@DavidKPiano](https://twitter.com/davidkpiano)) が興味深いツイートをしていました。

<!-- https://twitter.com/DavidKPiano/status/1353712136372039682 -->

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">State management libraries can be roughly categorized 2 ways:<br><br>⏺ Single (global, atomic store) vs. multi (local, distributed)<br>⚡️ Direct (manipulate state) vs. indirect (send events)<br><br>Here&#39;s how I&#39;d categorize some JS state management libraries: <a href="https://t.co/epkoZuBWyI">pic.twitter.com/epkoZuBWyI</a></p>&mdash; David K. 🎹 (@DavidKPiano) <a href="https://twitter.com/DavidKPiano/status/1353712136372039682?ref_src=twsrc%5Etfw">January 25, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

また、こうも言っています。

> Direct manipulation is "easier" than indirect manipulation, but is less safe.
>
> Single is "more convenient" than multi, but is more coupled.
>
> These trade-offs might be acceptable for your use-cases, but they're worth knowing.

つまり、状態管理ライブラリを大雑把ですが 2 つの視点でカテゴライズしています。

- 1 つのストア(global, atomic store) vs 複数のストア(local, distributed)
- 直接 State を変更 vs イベントで間接的に State を変更

そして、カテゴリにはそれぞれ以下のトレードオフがあり、許容できる場合でも知っておくことは価値があると言います。

- シングルストアはより便利に使えるが、複数のストアはデータを疎結合にできる。
- 直接更新は簡単。間接的な更新はより安全。

このトレードオフは、「読みやすさの基本定理」を目指す際には重要に感じます。
あえて安全よりも簡単を選択すること、もしくは簡単よりも安全を選択することの両方が、場合によっては読みやすさに繋がるからです。

そこで筆者は次回から、このツイートの画像を地図として扱い、以下にカテゴライズされるライブラリを実際に使ってみることで、そのトレードオフについて考えていきたいと思います。

- Multi × Direct
- Multi × Indirect
- Single × Direct
- Single × Indirect

次回は手始めに、最も有名なライブラリの Redux を紹介します。
